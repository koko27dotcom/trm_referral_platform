/**
 * PartnerReferral Model
 * Tracks referrals generated by partners
 * Manages commission calculations and payouts for partner-generated referrals
 */

const mongoose = require('mongoose');

const { Schema } = mongoose;

// Commission breakdown schema (embedded)
const CommissionBreakdownSchema = new Schema({
  type: {
    type: String,
    enum: ['base', 'bonus', 'tier_upgrade', 'promotional'],
    required: true,
  },
  description: {
    type: String,
    trim: true,
  },
  amount: {
    type: Number,
    required: true,
  },
  percentage: {
    type: Number,
  },
  calculatedAt: {
    type: Date,
    default: Date.now,
  },
}, { _id: true });

// Attribution data schema (embedded)
const AttributionSchema = new Schema({
  source: {
    type: String,
    trim: true,
  },
  medium: {
    type: String,
    trim: true,
  },
  campaign: {
    type: String,
    trim: true,
  },
  content: {
    type: String,
    trim: true,
  },
  term: {
    type: String,
    trim: true,
  },
  landingPage: {
    type: String,
    trim: true,
  },
  referrer: {
    type: String,
    trim: true,
  },
  ipAddress: {
    type: String,
  },
  userAgent: {
    type: String,
  },
  device: {
    type: String,
    enum: ['desktop', 'mobile', 'tablet'],
  },
  browser: {
    type: String,
  },
  os: {
    type: String,
  },
}, { _id: false });

// Click tracking schema (embedded)
const ClickSchema = new Schema({
  timestamp: {
    type: Date,
    default: Date.now,
  },
  ipAddress: {
    type: String,
  },
  userAgent: {
    type: String,
  },
  device: {
    type: String,
  },
  source: {
    type: String,
  },
}, { _id: true });

// Payout record schema (embedded)
const PayoutRecordSchema = new Schema({
  payoutId: {
    type: String,
    required: true,
  },
  amount: {
    type: Number,
    required: true,
  },
  method: {
    type: String,
    enum: ['bank_transfer', 'paypal', 'crypto', 'check'],
    required: true,
  },
  status: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'failed'],
    default: 'pending',
  },
  processedAt: {
    type: Date,
  },
  transactionId: {
    type: String,
  },
  notes: {
    type: String,
  },
}, { _id: true });

// Main PartnerReferral schema
const PartnerReferralSchema = new Schema({
  referralId: {
    type: String,
    required: true,
    unique: true,
    index: true,
  },
  partnerId: {
    type: Schema.Types.ObjectId,
    ref: 'Partner',
    required: true,
    index: true,
  },
  // Referral tracking code
  trackingCode: {
    type: String,
    required: true,
    index: true,
  },
  // What was referred
  referredType: {
    type: String,
    enum: ['company', 'referrer', 'job', 'subscription'],
    required: true,
  },
  referredId: {
    type: Schema.Types.ObjectId,
    required: true,
    refPath: 'referredType',
  },
  // Referred entity details (denormalized for quick access)
  referredDetails: {
    name: {
      type: String,
      trim: true,
    },
    email: {
      type: String,
      trim: true,
    },
    companyName: {
      type: String,
      trim: true,
    },
    subscriptionPlan: {
      type: String,
    },
    subscriptionAmount: {
      type: Number,
    },
  },
  // Referral status
  status: {
    type: String,
    enum: ['pending', 'clicked', 'signed_up', 'active', 'converted', 'expired', 'rejected'],
    default: 'pending',
  },
  // Status history
  statusHistory: [{
    status: {
      type: String,
      required: true,
    },
    changedAt: {
      type: Date,
      default: Date.now,
    },
    notes: {
      type: String,
    },
  }],
  // Click tracking
  clicks: [ClickSchema],
  clickCount: {
    type: Number,
    default: 0,
  },
  firstClickAt: {
    type: Date,
  },
  lastClickAt: {
    type: Date,
  },
  // Conversion tracking
  convertedAt: {
    type: Date,
  },
  conversionValue: {
    type: Number,
    default: 0,
  },
  // Commission details
  commissionAmount: {
    type: Number,
    default: 0,
  },
  commissionRate: {
    type: Number,
    default: 0,
  },
  commissionBreakdown: [CommissionBreakdownSchema],
  // Payout status
  payoutStatus: {
    type: String,
    enum: ['pending', 'eligible', 'scheduled', 'paid', 'cancelled'],
    default: 'pending',
  },
  payout: {
    type: PayoutRecordSchema,
  },
  // Attribution
  attribution: {
    type: AttributionSchema,
    default: () => ({}),
  },
  // Cookie/tracking
  cookieId: {
    type: String,
    index: true,
  },
  cookieExpiry: {
    type: Date,
  },
  // Multi-level tracking
  parentReferralId: {
    type: Schema.Types.ObjectId,
    ref: 'PartnerReferral',
  },
  level: {
    type: Number,
    default: 1, // 1 = direct, 2 = second level, etc.
  },
  // Campaign info
  campaignId: {
    type: String,
  },
  campaignName: {
    type: String,
    trim: true,
  },
  // Expiry
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days default
  },
  // Validation
  isValid: {
    type: Boolean,
    default: true,
  },
  validationNotes: {
    type: String,
  },
  // Fraud detection
  fraudScore: {
    type: Number,
    default: 0,
    min: 0,
    max: 100,
  },
  fraudFlags: [{
    type: String,
  }],
  // Notes
  notes: {
    type: String,
    trim: true,
  },
  // Timestamps
  createdAt: {
    type: Date,
    default: Date.now,
    index: true,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: { createdAt: true, updatedAt: true },
});

// Indexes
PartnerReferralSchema.index({ partnerId: 1, status: 1 });
PartnerReferralSchema.index({ trackingCode: 1 });
PartnerReferralSchema.index({ referredType: 1, referredId: 1 });
PartnerReferralSchema.index({ payoutStatus: 1 });
PartnerReferralSchema.index({ createdAt: -1 });
PartnerReferralSchema.index({ expiresAt: 1 });
PartnerReferralSchema.index({ cookieId: 1 });

// Virtual for days since creation
PartnerReferralSchema.virtual('daysSinceCreated').get(function() {
  return Math.floor((Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60 * 24));
});

// Virtual for conversion rate (if clicks > 0)
PartnerReferralSchema.virtual('clickToConversionRate').get(function() {
  if (this.clickCount === 0) return 0;
  return this.status === 'converted' ? 100 : 0;
});

// Method to record a click
PartnerReferralSchema.methods.recordClick = async function(clickData) {
  this.clicks.push(clickData);
  this.clickCount += 1;
  
  if (!this.firstClickAt) {
    this.firstClickAt = new Date();
  }
  this.lastClickAt = new Date();
  
  if (this.status === 'pending') {
    this.status = 'clicked';
    this.statusHistory.push({ status: 'clicked', notes: 'First click recorded' });
  }
  
  return this.save();
};

// Method to mark as converted
PartnerReferralSchema.methods.markConverted = async function(conversionData) {
  this.status = 'converted';
  this.convertedAt = new Date();
  this.conversionValue = conversionData.value || 0;
  
  if (conversionData.referredDetails) {
    this.referredDetails = { ...this.referredDetails, ...conversionData.referredDetails };
  }
  
  this.statusHistory.push({
    status: 'converted',
    notes: `Conversion value: ${conversionData.value}`,
  });
  
  // Calculate commission
  await this.calculateCommission(conversionData.commissionRate);
  
  return this.save();
};

// Method to calculate commission
PartnerReferralSchema.methods.calculateCommission = async function(rate) {
  this.commissionRate = rate || 10;
  
  const baseAmount = this.conversionValue * (this.commissionRate / 100);
  
  this.commissionBreakdown = [{
    type: 'base',
    description: 'Base commission',
    amount: baseAmount,
    percentage: this.commissionRate,
  }];
  
  // Add any bonuses
  let totalCommission = baseAmount;
  
  // Level-based adjustment for multi-level
  if (this.level > 1) {
    const levelMultiplier = Math.pow(0.5, this.level - 1); // 50% reduction per level
    const levelBonus = baseAmount * levelMultiplier - baseAmount;
    
    if (levelBonus !== 0) {
      this.commissionBreakdown.push({
        type: 'bonus',
        description: `Level ${this.level} adjustment`,
        amount: levelBonus,
      });
      totalCommission += levelBonus;
    }
  }
  
  this.commissionAmount = Math.max(0, totalCommission);
  this.payoutStatus = 'eligible';
  
  return this;
};

// Method to process payout
PartnerReferralSchema.methods.processPayout = async function(payoutData) {
  this.payout = {
    ...payoutData,
    status: 'pending',
  };
  this.payoutStatus = 'scheduled';
  
  return this.save();
};

// Method to complete payout
PartnerReferralSchema.methods.completePayout = async function(transactionId) {
  if (this.payout) {
    this.payout.status = 'completed';
    this.payout.processedAt = new Date();
    this.payout.transactionId = transactionId;
    this.payoutStatus = 'paid';
  }
  
  return this.save();
};

// Method to check if expired
PartnerReferralSchema.methods.checkExpiry = function() {
  if (this.expiresAt && new Date() > this.expiresAt) {
    if (this.status !== 'converted') {
      this.status = 'expired';
      this.statusHistory.push({
        status: 'expired',
        notes: 'Referral link expired',
      });
      return true;
    }
  }
  return false;
};

// Static method to get partner stats
PartnerReferralSchema.statics.getPartnerStats = async function(partnerId, dateRange = {}) {
  const matchStage = { partnerId: new mongoose.Types.ObjectId(partnerId) };
  
  if (dateRange.startDate || dateRange.endDate) {
    matchStage.createdAt = {};
    if (dateRange.startDate) matchStage.createdAt.$gte = new Date(dateRange.startDate);
    if (dateRange.endDate) matchStage.createdAt.$lte = new Date(dateRange.endDate);
  }
  
  const stats = await this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: null,
        totalReferrals: { $sum: 1 },
        totalClicks: { $sum: '$clickCount' },
        converted: {
          $sum: { $cond: [{ $eq: ['$status', 'converted'] }, 1, 0] },
        },
        totalCommission: { $sum: '$commissionAmount' },
        pendingCommission: {
          $sum: {
            $cond: [
              { $eq: ['$payoutStatus', 'eligible'] },
              '$commissionAmount',
              0,
            ],
          },
        },
        paidCommission: {
          $sum: {
            $cond: [
              { $eq: ['$payoutStatus', 'paid'] },
              '$commissionAmount',
              0,
            ],
          },
        },
      },
    },
  ]);
  
  return stats[0] || {
    totalReferrals: 0,
    totalClicks: 0,
    converted: 0,
    totalCommission: 0,
    pendingCommission: 0,
    paidCommission: 0,
  };
};

// Static method to get referrals pending payout
PartnerReferralSchema.statics.getPendingPayouts = function(partnerId) {
  return this.find({
    partnerId,
    payoutStatus: 'eligible',
    status: 'converted',
  }).sort({ convertedAt: 1 });
};

// Static method to find by tracking code
PartnerReferralSchema.statics.findByTrackingCode = function(code) {
  return this.findOne({ trackingCode: code });
};

const PartnerReferral = mongoose.model('PartnerReferral', PartnerReferralSchema);

module.exports = PartnerReferral;
